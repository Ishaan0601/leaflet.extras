{"version":3,"file":"lfx-geodesic-prod.js","mappings":"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","sources":["webpack://leaflet.extras/./node_modules/Leaflet.Geodesic/Leaflet.Geodesic.js"],"sourcesContent":["\"use strict\";\n\n// This file is part of Leaflet.Geodesic.\n// Copyright (C) 2017  Henry Thasler\n// based on code by Chris Veness Copyright (C) 2014 https://github.com/chrisveness/geodesy\n//\n// Leaflet.Geodesic is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Leaflet.Geodesic is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Leaflet.Geodesic.  If not, see <http://www.gnu.org/licenses/>.\n\n\n/** Extend Number object with method to convert numeric degrees to radians */\nif (typeof Number.prototype.toRadians === \"undefined\") {\n  Number.prototype.toRadians = function() {\n    return this * Math.PI / 180;\n  };\n}\n\n/** Extend Number object with method to convert radians to numeric (signed) degrees */\nif (typeof Number.prototype.toDegrees === \"undefined\") {\n  Number.prototype.toDegrees = function() {\n    return this * 180 / Math.PI;\n  };\n}\n\nvar INTERSECT_LNG = 179.999; // Lng used for intersection and wrap around on map edges\n\nL.Geodesic = L.Polyline.extend({\n  options: {\n    color: \"blue\",\n    steps: 10,\n    dash: 1,\n    wrap: true\n  },\n\n  initialize: function(latlngs, options) {\n    this.options = this._merge_options(this.options, options);\n    this.options.dash = Math.max(1e-3, Math.min(1, parseFloat(this.options.dash) || 1));\n    this.datum = {};\n    this.datum.ellipsoid = {\n        a: 6378137,\n        b: 6356752.3142,\n        f: 1 / 298.257223563\n      }; // WGS-84\n    this._latlngs = this._generate_Geodesic(latlngs);\n    L.Polyline.prototype.initialize.call(this, this._latlngs, this.options);\n  },\n\n  setLatLngs: function(latlngs) {\n    this._latlngs = this._generate_Geodesic(latlngs);\n    L.Polyline.prototype.setLatLngs.call(this, this._latlngs);\n  },\n\n  /**\n   * Calculates some statistic values of current geodesic multipolyline\n   * @returns (Object} Object with several properties (e.g. overall distance)\n   */\n  getStats: function() {\n    let obj = {\n        distance: 0,\n        points: 0,\n        polygons: this._latlngs.length\n      }, poly, points;\n\n    for (poly = 0; poly < this._latlngs.length; poly++) {\n      obj.points += this._latlngs[poly].length;\n      for (points = 0; points < (this._latlngs[poly].length - 1); points++) {\n        obj.distance += this._vincenty_inverse(this._latlngs[poly][points],\n          this._latlngs[poly][points + 1]).distance;\n      }\n    }\n    return obj;\n  },\n\n\n  /**\n   * Creates geodesic lines from geoJson. Replaces all current features of this instance.\n   * Supports LineString, MultiLineString and Polygon\n   * @param {Object} geojson - geosjon as object.\n   */\n  geoJson: function(geojson) {\n\n    let normalized = L.GeoJSON.asFeature(geojson);\n    let features = normalized.type === \"FeatureCollection\" ? normalized.features : [\n      normalized\n    ];\n    this._latlngs = [];\n    for (let feature of features) {\n      let geometry = feature.type === \"Feature\" ? feature.geometry :\n        feature,\n        coords = geometry.coordinates;\n\n      switch (geometry.type) {\n        case \"LineString\":\n          this._latlngs.push(this._generate_Geodesic([L.GeoJSON.coordsToLatLngs(\n            coords, 0)]));\n          break;\n        case \"MultiLineString\":\n        case \"Polygon\":\n          this._latlngs.push(this._generate_Geodesic(L.GeoJSON.coordsToLatLngs(\n            coords, 1)));\n          break;\n        case \"Point\":\n        case \"MultiPoint\":\n          console.log(\"Dude, points can't be drawn as geodesic lines...\");\n          break;\n        default:\n          console.log(\"Drawing \" + geometry.type +\n            \" as a geodesic is not supported. Skipping...\");\n      }\n    }\n    L.Polyline.prototype.setLatLngs.call(this, this._latlngs);\n  },\n\n  /**\n   * Creates a great circle. Replaces all current lines.\n   * @param {Object} center - geographic position\n   * @param {number} radius - radius of the circle in metres\n   */\n  createCircle: function(center, radius) {\n    let polylineIndex = 0;\n    let prev = {\n      lat: 0,\n      lng: 0,\n      brg: 0\n    };\n    let step;\n\n    this._latlngs = [];\n    this._latlngs[polylineIndex] = [];\n\n    let direct = this._vincenty_direct(L.latLng(center), 0, radius, this.options\n      .wrap);\n    prev = L.latLng(direct.lat, direct.lng);\n    this._latlngs[polylineIndex].push(prev);\n    for (step = 1; step <= this.options.steps;) {\n      direct = this._vincenty_direct(L.latLng(center), 360 / this.options\n        .steps * step, radius, this.options.wrap);\n      let gp = L.latLng(direct.lat, direct.lng);\n      if (Math.abs(gp.lng - prev.lng) > 180) {\n        let inverse = this._vincenty_inverse(prev, gp);\n        let sec = this._intersection(prev, inverse.initialBearing, {\n          lat: -89,\n          lng: ((gp.lng - prev.lng) > 0) ? -INTERSECT_LNG : INTERSECT_LNG\n        }, 0);\n        if (sec) {\n          this._latlngs[polylineIndex].push(L.latLng(sec.lat, sec.lng));\n          polylineIndex++;\n          this._latlngs[polylineIndex] = [];\n          prev = L.latLng(sec.lat, -sec.lng);\n          this._latlngs[polylineIndex].push(prev);\n        } else {\n          polylineIndex++;\n          this._latlngs[polylineIndex] = [];\n          this._latlngs[polylineIndex].push(gp);\n          prev = gp;\n          step++;\n        }\n      } else {\n        this._latlngs[polylineIndex].push(gp);\n        prev = gp;\n        step++;\n      }\n    }\n\n    L.Polyline.prototype.setLatLngs.call(this, this._latlngs);\n  },\n\n  /**\n   * Creates a geodesic Polyline from given coordinates\n   * Note: dashed lines are under work\n   * @param {Object} latlngs - One or more polylines as an array. See Leaflet doc about Polyline\n   * @returns (Object} An array of arrays of geographical points.\n   */\n  _generate_Geodesic: function(latlngs) {\n    let _geo = [], _geocnt = 0;\n\n    for (let poly = 0; poly < latlngs.length; poly++) {\n      _geo[_geocnt] = [];\n      let prev = L.latLng(latlngs[poly][0]);\n      for (let points = 0; points < (latlngs[poly].length - 1); points++) {\n        // use prev, so that wrapping behaves correctly\n        let pointA = prev;\n        let pointB = L.latLng(latlngs[poly][points + 1]);\n        if (pointA.equals(pointB)) {\n          continue;\n        }\n        let inverse = this._vincenty_inverse(pointA, pointB);\n        _geo[_geocnt].push(prev);\n        for (let s = 1; s <= this.options.steps;) {\n          let distance = inverse.distance / this.options.steps;\n          // dashed lines don't go the full distance between the points\n          let dist_mult = s - 1 + this.options.dash;\n          let direct = this._vincenty_direct(pointA, inverse.initialBearing, distance*dist_mult, this.options.wrap);\n          let gp = L.latLng(direct.lat, direct.lng);\n          if (Math.abs(gp.lng - prev.lng) > 180) {\n            let sec = this._intersection(pointA, inverse.initialBearing, {\n              lat: -89,\n              lng: ((gp.lng - prev.lng) > 0) ? -INTERSECT_LNG : INTERSECT_LNG\n            }, 0);\n            if (sec) {\n              _geo[_geocnt].push(L.latLng(sec.lat, sec.lng));\n              _geocnt++;\n              _geo[_geocnt] = [];\n              prev = L.latLng(sec.lat, -sec.lng);\n              _geo[_geocnt].push(prev);\n            } else {\n              _geocnt++;\n              _geo[_geocnt] = [];\n              _geo[_geocnt].push(gp);\n              prev = gp;\n              s++;\n            }  \n          } else {\n            _geo[_geocnt].push(gp);\n            // Dashed lines start a new line\n            if (this.options.dash < 1){\n                _geocnt++;\n                // go full distance this time, to get starting point for next line\n                let direct_full = this._vincenty_direct(pointA, inverse.initialBearing, distance*s, this.options.wrap);\n                _geo[_geocnt] = [];\n                prev = L.latLng(direct_full.lat, direct_full.lng);\n                _geo[_geocnt].push(prev);\n            }\n            else prev = gp;\n            s++;\n          }\n        }\n      }\n      _geocnt++;\n    }\n    return _geo;\n  },\n\n  /**\n   * Vincenty direct calculation.\n   * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)\n   *\n   * @private\n   * @param {number} initialBearing - Initial bearing in degrees from north.\n   * @param {number} distance - Distance along bearing in metres.\n   * @returns (Object} Object including point (destination point), finalBearing.\n   */\n\n  _vincenty_direct: function(p1, initialBearing, distance, wrap) {\n    var φ1 = p1.lat.toRadians(),\n      λ1 = p1.lng.toRadians();\n    var α1 = initialBearing.toRadians();\n    var s = distance;\n\n    var a = this.datum.ellipsoid.a,\n      b = this.datum.ellipsoid.b,\n      f = this.datum.ellipsoid.f;\n\n    var sinα1 = Math.sin(α1);\n    var cosα1 = Math.cos(α1);\n\n    var tanU1 = (1 - f) * Math.tan(φ1),\n      cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)),\n      sinU1 = tanU1 * cosU1;\n    var σ1 = Math.atan2(tanU1, cosα1);\n    var sinα = cosU1 * sinα1;\n    var cosSqα = 1 - sinα * sinα;\n    var uSq = cosSqα * (a * a - b * b) / (b * b);\n    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 *\n      uSq)));\n    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n\n    var σ = s / (b * A),\n      σʹ, iterations = 0;\n    var sinσ, cosσ;\n    var cos2σM;\n    do {\n      cos2σM = Math.cos(2 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      var Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM *\n          cos2σM) -\n        B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM *\n          cos2σM)));\n      σʹ = σ;\n      σ = s / (b * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > 1e-12 && ++iterations);\n\n    var x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    var φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - f) *\n      Math.sqrt(sinα * sinα + x * x));\n    var λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    var C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));\n    var L = λ - (1 - C) * f * sinα *\n      (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));\n\n    var λ2;\n    if (wrap) {\n      λ2 = (λ1 + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180...+180\n    } else {\n      λ2 = (λ1 + L); // do not normalize\n    }\n\n    var revAz = Math.atan2(sinα, -x);\n\n    return {\n      lat: φ2.toDegrees(),\n      lng: λ2.toDegrees(),\n      finalBearing: revAz.toDegrees()\n    };\n  },\n\n  /**\n   * Vincenty inverse calculation.\n   * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)\n   *\n   * @private\n   * @param {LatLng} p1 - Latitude/longitude of start point.\n   * @param {LatLng} p2 - Latitude/longitude of destination point.\n   * @returns {Object} Object including distance, initialBearing, finalBearing.\n   * @throws {Error} If formula failed to converge.\n   */\n  _vincenty_inverse: function(p1, p2) {\n    var φ1 = p1.lat.toRadians(),\n      λ1 = p1.lng.toRadians();\n    var φ2 = p2.lat.toRadians(),\n      λ2 = p2.lng.toRadians();\n\n    var a = this.datum.ellipsoid.a,\n      b = this.datum.ellipsoid.b,\n      f = this.datum.ellipsoid.f;\n\n    var L = λ2 - λ1;\n    var tanU1 = (1 - f) * Math.tan(φ1),\n      cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)),\n      sinU1 = tanU1 * cosU1;\n    var tanU2 = (1 - f) * Math.tan(φ2),\n      cosU2 = 1 / Math.sqrt((1 + tanU2 * tanU2)),\n      sinU2 = tanU2 * cosU2;\n\n    var λ = L,\n      λʹ, iterations = 0;\n    var cosSqα, sinσ, cos2σM, cosσ, σ, sinλ, cosλ;\n    do {\n      sinλ = Math.sin(λ);\n      cosλ = Math.cos(λ);\n      var sinSqσ = (cosU2 * sinλ) * (cosU2 * sinλ) + (cosU1 * sinU2 -\n        sinU1 * cosU2 * cosλ) * (cosU1 * sinU2 - sinU1 * cosU2 * cosλ);\n      sinσ = Math.sqrt(sinSqσ);\n      if (sinσ == 0) return 0; // co-incident points\n      cosσ = sinU1 * sinU2 + cosU1 * cosU2 * cosλ;\n      σ = Math.atan2(sinσ, cosσ);\n      var sinα = cosU1 * cosU2 * sinλ / sinσ;\n      cosSqα = 1 - sinα * sinα;\n      cos2σM = cosσ - 2 * sinU1 * sinU2 / cosSqα;\n      if (isNaN(cos2σM)) cos2σM = 0; // equatorial line: cosSqα=0 (§6)\n      var C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));\n      λʹ = λ;\n      λ = L + (1 - C) * f * sinα * (σ + C * sinσ * (cos2σM + C * cosσ * (-\n        1 + 2 * cos2σM * cos2σM)));\n    } while (Math.abs(λ - λʹ) > 1e-12 && ++iterations < 100);\n    if (iterations >= 100) {\n      console.log(\"Formula failed to converge. Altering target position.\");\n      return this._vincenty_inverse(p1, {\n          lat: p2.lat,\n          lng: p2.lng - 0.01\n        });\n        //  throw new Error('Formula failed to converge');\n    }\n\n    var uSq = cosSqα * (a * a - b * b) / (b * b);\n    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 *\n      uSq)));\n    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n    var Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM *\n        cos2σM) -\n      B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM *\n        cos2σM)));\n\n    var s = b * A * (σ - Δσ);\n\n    var fwdAz = Math.atan2(cosU2 * sinλ, cosU1 * sinU2 - sinU1 * cosU2 *\n      cosλ);\n    var revAz = Math.atan2(cosU1 * sinλ, -sinU1 * cosU2 + cosU1 * sinU2 *\n      cosλ);\n\n    s = Number(s.toFixed(3)); // round to 1mm precision\n    return {\n      distance: s,\n      initialBearing: fwdAz.toDegrees(),\n      finalBearing: revAz.toDegrees()\n    };\n  },\n\n\n  /**\n   * Returns the point of intersection of two paths defined by point and bearing.\n   * based on the work of Chris Veness (https://github.com/chrisveness/geodesy)\n   *\n   * @param {LatLon} p1 - First point.\n   * @param {number} brng1 - Initial bearing from first point.\n   * @param {LatLon} p2 - Second point.\n   * @param {number} brng2 - Initial bearing from second point.\n   * @returns {Object} containing lat/lng information of intersection.\n   *\n   * @example\n   * var p1 = LatLon(51.8853, 0.2545), brng1 = 108.55;\n   * var p2 = LatLon(49.0034, 2.5735), brng2 = 32.44;\n   * var pInt = LatLon.intersection(p1, brng1, p2, brng2); // pInt.toString(): 50.9078°N, 4.5084°E\n   */\n  _intersection: function(p1, brng1, p2, brng2) {\n    // see http://williams.best.vwh.net/avform.htm#Intersection\n\n    var φ1 = p1.lat.toRadians(),\n      λ1 = p1.lng.toRadians();\n    var φ2 = p2.lat.toRadians(),\n      λ2 = p2.lng.toRadians();\n    var θ13 = Number(brng1).toRadians(),\n      θ23 = Number(brng2).toRadians();\n    var Δφ = φ2 - φ1,\n      Δλ = λ2 - λ1;\n\n    var δ12 = 2 * Math.asin(Math.sqrt(Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ /\n        2)));\n    if (δ12 == 0) return null;\n\n    // initial/final bearings between points\n    var θ1 = Math.acos((Math.sin(φ2) - Math.sin(φ1) * Math.cos(δ12)) /\n      (Math.sin(δ12) * Math.cos(φ1)));\n    if (isNaN(θ1)) θ1 = 0; // protect against rounding\n    var θ2 = Math.acos((Math.sin(φ1) - Math.sin(φ2) * Math.cos(δ12)) /\n      (Math.sin(δ12) * Math.cos(φ2)));\n    var θ12, θ21;\n    if (Math.sin(λ2 - λ1) > 0) {\n      θ12 = θ1;\n      θ21 = 2 * Math.PI - θ2;\n    } else {\n      θ12 = 2 * Math.PI - θ1;\n      θ21 = θ2;\n    }\n\n    var α1 = (θ13 - θ12 + Math.PI) % (2 * Math.PI) - Math.PI; // angle 2-1-3\n    var α2 = (θ21 - θ23 + Math.PI) % (2 * Math.PI) - Math.PI; // angle 1-2-3\n\n    if (Math.sin(α1) == 0 && Math.sin(α2) == 0) return null; // infinite intersections\n    if (Math.sin(α1) * Math.sin(α2) < 0) return null; // ambiguous intersection\n\n    //α1 = Math.abs(α1);\n    //α2 = Math.abs(α2);\n    // ... Ed Williams takes abs of α1/α2, but seems to break calculation?\n\n    var α3 = Math.acos(-Math.cos(α1) * Math.cos(α2) +\n      Math.sin(α1) * Math.sin(α2) * Math.cos(δ12));\n    var δ13 = Math.atan2(Math.sin(δ12) * Math.sin(α1) * Math.sin(α2),\n      Math.cos(α2) + Math.cos(α1) * Math.cos(α3));\n    var φ3 = Math.asin(Math.sin(φ1) * Math.cos(δ13) +\n      Math.cos(φ1) * Math.sin(δ13) * Math.cos(θ13));\n    var Δλ13 = Math.atan2(Math.sin(θ13) * Math.sin(δ13) * Math.cos(φ1),\n      Math.cos(δ13) - Math.sin(φ1) * Math.sin(φ3));\n    var λ3 = λ1 + Δλ13;\n    λ3 = (λ3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180º\n\n    return {\n      lat: φ3.toDegrees(),\n      lng: λ3.toDegrees()\n    };\n  },\n\n  /**\n   * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\n   * @param obj1\n   * @param obj2\n   * @returns obj3 a new object based on obj1 and obj2\n   */\n  _merge_options: function(obj1, obj2) {\n    let obj3 = {};\n    for (let attrname in obj1) {\n      obj3[attrname] = obj1[attrname];\n    }\n    for (let attrname in obj2) {\n      obj3[attrname] = obj2[attrname];\n    }\n    return obj3;\n  }\n});\n\nL.geodesic = function(latlngs, options) {\n  return new L.Geodesic(latlngs, options);\n};\n"],"names":["Number","prototype","toRadians","this","Math","PI","toDegrees","INTERSECT_LNG","L","Geodesic","Polyline","extend","options","color","steps","dash","wrap","initialize","latlngs","_merge_options","max","min","parseFloat","datum","ellipsoid","a","b","f","_latlngs","_generate_Geodesic","call","setLatLngs","getStats","poly","points","obj","distance","polygons","length","_vincenty_inverse","geoJson","geojson","normalized","GeoJSON","asFeature","features","type","feature","geometry","coords","coordinates","push","coordsToLatLngs","console","log","createCircle","center","radius","step","polylineIndex","prev","lat","lng","brg","direct","_vincenty_direct","latLng","gp","abs","inverse","sec","_intersection","initialBearing","_geo","_geocnt","pointA","pointB","equals","s","dist_mult","direct_full","p1","sin","cos","tanU1","tan","cosU1","sqrt","sinU1","atan2","uSq","A","B","iterations","x","C","revAz","finalBearing","p2","tanU2","cosU2","sinU2","isNaN","fwdAz","toFixed","brng1","brng2","asin","acos","obj1","obj2","obj3","attrname","geodesic"],"sourceRoot":""}