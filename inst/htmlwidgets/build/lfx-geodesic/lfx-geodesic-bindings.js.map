{"version":3,"file":"lfx-geodesic-bindings.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B;AAC9B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://leaflet.extras/./inst/htmlwidgets/bindings/lfx-geodesic-bindings.js"],"sourcesContent":["/* global $, LeafletWidget, L, HTMLWidgets */\r\nLeafletWidget.methods.addGeodesicPolylines  = function(\r\n  polygons, layerId, group, options, popup, popupOptions,\r\n  label, labelOptions, highlightOptions) {\r\n  if(polygons.length > 0) {\r\n    var df = new LeafletWidget.DataFrame()\r\n      .col('shapes', polygons)\r\n      .col('layerId', layerId)\r\n      .col('group', group)\r\n      .col('popup', popup)\r\n      .col('popupOptions', popupOptions)\r\n      .col('label', label)\r\n      .col('labelOptions', labelOptions)\r\n      .col('highlightOptions', highlightOptions)\r\n      .cbind(options);\r\n\r\n    LeafletWidget.methods.addGenericLayers(this, 'shape', df,\r\n      function(df, i) {\r\n        var shapes = df.get(i, 'shapes');\r\n        var ret_shapes = [];\r\n        for (var j = 0; j < shapes.length; j++) {\r\n          for (var k = 0; k < shapes[j].length; k++) {\r\n            ret_shapes.push(\r\n              HTMLWidgets.dataframeToD3(shapes[j][k])\r\n            );\r\n          }\r\n        }\r\n        return L.geodesic(ret_shapes, df.get(i));\r\n      });\r\n  }\r\n};\r\n\r\n\r\n// from https://github.com/rstudio/leaflet/blob/dc772e780317481e25335449b957c5f50082bcfd/javascript/src/methods.js#L221\r\nfunction unpackStrings(iconset) {\r\n  if (!iconset) {\r\n    return iconset;\r\n  }\r\n  if (typeof(iconset.index) === \"undefined\") {\r\n    return iconset;\r\n  }\r\n\r\n  iconset.data = asArray(iconset.data);\r\n  iconset.index = asArray(iconset.index);\r\n\r\n  return $.map(iconset.index, function(e, i) {\r\n    return iconset.data[e];\r\n  });\r\n}\r\n\r\nLeafletWidget.methods.addGreatCircles  = function(\r\n  lat, lng, radius, layerId, group, options, icon, popup, popupOptions,\r\n  label, labelOptions, highlightOptions, markerOptions) {\r\n  if(!($.isEmptyObject(lat) || $.isEmptyObject(lng)) ||\r\n      ($.isNumeric(lat) && $.isNumeric(lng))) {\r\n    const map = this;\r\n\r\n    let icondf;\r\n    let getIcon;\r\n\r\n    if (icon) {\r\n      // Unpack icons\r\n      icon.iconUrl         = unpackStrings(icon.iconUrl);\r\n      icon.iconRetinaUrl   = unpackStrings(icon.iconRetinaUrl);\r\n      icon.shadowUrl       = unpackStrings(icon.shadowUrl);\r\n      icon.shadowRetinaUrl = unpackStrings(icon.shadowRetinaUrl);\r\n\r\n      // This cbinds the icon URLs and any other icon options; they're all\r\n      // present on the icon object.\r\n      icondf = new LeafletWidget.DataFrame().cbind(icon);\r\n\r\n      // Constructs an icon from a specified row of the icon dataframe.\r\n      getIcon = function(i) {\r\n        let opts = icondf.get(i);\r\n        if (!opts.iconUrl) {\r\n          return new L.Icon.Default();\r\n        }\r\n\r\n        // Composite options (like points or sizes) are passed from R with each\r\n        // individual component as its own option. We need to combine them now\r\n        // into their composite form.\r\n        if (opts.iconWidth) {\r\n          opts.iconSize = [opts.iconWidth, opts.iconHeight];\r\n        }\r\n        if (opts.shadowWidth) {\r\n          opts.shadowSize = [opts.shadowWidth, opts.shadowHeight];\r\n        }\r\n        if (opts.iconAnchorX) {\r\n          opts.iconAnchor = [opts.iconAnchorX, opts.iconAnchorY];\r\n        }\r\n        if (opts.shadowAnchorX) {\r\n          opts.shadowAnchor = [opts.shadowAnchorX, opts.shadowAnchorY];\r\n        }\r\n        if (opts.popupAnchorX) {\r\n          opts.popupAnchor = [opts.popupAnchorX, opts.popupAnchorY];\r\n        }\r\n\r\n        return new L.Icon(opts);\r\n      };\r\n    }\r\n    if (icon) icondf.effectiveLength = lat.length;\r\n\r\n    // Function to normalize access to values, either from arrays or scalars\r\n    const getValue = (prop, index) => Array.isArray(prop) ? (prop[index] || prop[prop.length - 1]) : prop;\r\n\r\n    const locations = [];\r\n    for (let i = 0; i < lat.length; i++) {\r\n        locations.push({\r\n            lat: getValue(lat, i),\r\n            lng: getValue(lng, i),\r\n            layerId: getValue(layerId, i),\r\n            radius: getValue(radius, i),\r\n            popup: getValue(popup, i),\r\n            label: getValue(label, i),\r\n            weight: getValue(options.weight, i),\r\n            color: getValue(options.color, i),\r\n            opacity: getValue(options.opacity, i),\r\n            steps: getValue(options.steps, i),\r\n        });\r\n    }\r\n    console.log(\"locations\"); console.log(locations)\r\n    console.log(\"options\");console.log(options);\r\n\r\n    // Add GeodesicCircle and Center Marker\r\n    locations.forEach((location, i) => {\r\n      const latlong = new L.LatLng(location.lat, location.lng)\r\n\r\n      // Create a geodesic circle for each location\r\n      const geodesicCircle = new L.GeodesicCircle(latlong, {\r\n          weight: location.weight,\r\n          opacity: location.opacity,\r\n          color: location.color,\r\n          steps: location.steps,\r\n          fill: options.fill === true,\r\n          wrap: options.wrap === true,\r\n          dashArray: options.dashArray,\r\n          smoothFactor: options.smoothFactor,\r\n          noClip: options.noClip,\r\n      })\r\n        //.addTo(map);\r\n      map.layerManager.addLayer(geodesicCircle, \"shape\", location.layerId, group)\r\n\r\n      if (label !== null) {\r\n        if (labelOptions !== null) {\r\n          geodesicCircle.bindTooltip(location.label, labelOptions)\r\n        } else {\r\n          geodesicCircle.bindTooltip(location.label)\r\n        }\r\n      }\r\n      if (popup !== null) {\r\n        if (popupOptions  !== null) {\r\n          geodesicCircle.bindPopup(location.popup, popupOptions)\r\n        } else {\r\n          geodesicCircle.bindPopup(location.popup)\r\n        }\r\n      }\r\n\r\n      if (icon) markerOptions.icon = getIcon(i);\r\n\r\n      // Create a marker for each location\r\n      const marker = L.marker(latlong, markerOptions)\r\n        .addTo(map);\r\n      if (label !== null) {\r\n        if (labelOptions !== null) {\r\n          marker.bindTooltip(location.label, labelOptions)\r\n        } else {\r\n          marker.bindTooltip(location.label)\r\n        }\r\n      }\r\n      if (popup !== null) {\r\n        if (popupOptions  !== null) {\r\n          marker.bindPopup(location.popup, popupOptions)\r\n        } else {\r\n          marker.bindPopup(location.popup)\r\n        }\r\n      }\r\n\r\n      // Drag event listener for Center marker\r\n      marker.on('drag', (e) => {\r\n          // Update the geodesic circle's position and information\r\n          geodesicCircle.setLatLng(e.latlng);\r\n\r\n          // Assuming 'info' and 'updateInfo' function are defined elsewhere to update the control based on new stats\r\n          if (options.showStats) {\r\n            updateInfo(geodesicCircle.statistics); // You need to define or adjust the 'updateInfo' function\r\n          }\r\n\r\n          // Listen for Events in Shinymode\r\n          if (HTMLWidgets.shinyMode) {\r\n            Shiny.onInputChange(map.id + \"_geodesic_stats\", geodesicCircle.statistics);\r\n          }\r\n      });\r\n      marker.on('click', (e) => {\r\n        console.log(\"click\");console.log(e);\r\n        // Listen for Events in Shinymode\r\n        if (HTMLWidgets.shinyMode) {\r\n          Shiny.onInputChange(map.id + \"_geodesic_click\", geodesicCircle.statistics);\r\n        }\r\n      });\r\n\r\n      // Highlight -\r\n      let highlightStyle = highlightOptions;\r\n      if(!$.isEmptyObject(highlightStyle)) {\r\n        let defaultStyle = {};\r\n        $.each(highlightStyle, function (k, v) {\r\n          if (k != \"bringToFront\" && k != \"sendToBack\"){\r\n            if (location[k]) {\r\n              defaultStyle[k] = location[k];\r\n            }\r\n          }\r\n        });\r\n\r\n        geodesicCircle.on(\"mouseover\", function(e) {\r\n            this.setStyle(highlightStyle);\r\n            if(highlightStyle.bringToFront) {\r\n              this.bringToFront();\r\n            }\r\n          });\r\n        geodesicCircle.on(\"mouseout\", function(e) {\r\n            this.setStyle(defaultStyle);\r\n            if(highlightStyle.sendToBack) {\r\n              this.bringToBack();\r\n            }\r\n          });\r\n      }\r\n\r\n    });\r\n\r\n\r\n    if (options.showStats) {\r\n      // Info control\r\n      var info = L.control();\r\n      info.onAdd = function(map) {\r\n          this._div = L.DomUtil.create('div', 'info');\r\n          return this._div;\r\n      };\r\n      info.addTo(map);\r\n\r\n\r\n      // Define a function to update the info control based on passed statistics\r\n      function updateInfo(stats, statsFunction) {\r\n        console.log(\"update info\"); console.log(stats);\r\n        var infoHTML = \"\";\r\n        if (typeof options.statsFunction === \"function\") {\r\n          // If additionalInput is a function, use it to generate content exclusively\r\n          infoHTML = options.statsFunction(stats);\r\n        } else {\r\n          // Default content generation logic\r\n          const totalDistance = stats.totalDistance ? (stats.totalDistance > 10000 ? (stats.totalDistance / 1000).toFixed(0) + ' km' : stats.totalDistance.toFixed(0) + ' m') : 'invalid';\r\n          infoHTML = '<h4>Statistics</h4>' +\r\n            '<b>Total Distance</b><br/>' + totalDistance +\r\n            '<br/><br/><b>Points</b><br/>' + stats.points +\r\n            '<br/><br/><b>Vertices</b><br/>' + stats.vertices;\r\n        }\r\n        // Update the innerHTML of the info div with the constructed info HTML or leave it empty\r\n        info._div.innerHTML = infoHTML;\r\n      }\r\n    }\r\n\r\n\r\n  }\r\n};\r\n"],"names":[],"sourceRoot":""}