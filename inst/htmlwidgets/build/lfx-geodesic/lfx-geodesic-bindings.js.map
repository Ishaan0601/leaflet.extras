{"version":3,"file":"lfx-geodesic-bindings.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8BAA8B;AAC9B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,kCAAkC;AAClC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://leaflet.extras/./inst/htmlwidgets/bindings/lfx-geodesic-bindings.js"],"sourcesContent":["/* global $, LeafletWidget, L, HTMLWidgets */\r\nLeafletWidget.methods.addGeodesicPolylines  = function(\r\n  polygons, layerId, group, options, popup, popupOptions,\r\n  label, labelOptions, highlightOptions) {\r\n  if(polygons.length > 0) {\r\n    var df = new LeafletWidget.DataFrame()\r\n      .col('shapes', polygons)\r\n      .col('layerId', layerId)\r\n      .col('group', group)\r\n      .col('popup', popup)\r\n      .col('popupOptions', popupOptions)\r\n      .col('label', label)\r\n      .col('labelOptions', labelOptions)\r\n      .col('highlightOptions', highlightOptions)\r\n      .cbind(options);\r\n\r\n    LeafletWidget.methods.addGenericLayers(this, 'shape', df,\r\n      function(df, i) {\r\n        var shapes = df.get(i, 'shapes');\r\n        var ret_shapes = [];\r\n        for (var j = 0; j < shapes.length; j++) {\r\n          for (var k = 0; k < shapes[j].length; k++) {\r\n            ret_shapes.push(\r\n              HTMLWidgets.dataframeToD3(shapes[j][k])\r\n            );\r\n          }\r\n        }\r\n        return L.geodesic(ret_shapes, df.get(i));\r\n      });\r\n  }\r\n};\r\n\r\n\r\nLeafletWidget.methods.addGreatCircles  = function(\r\n  lat, lng, radius, layerId, group, options, popup, popupOptions,\r\n  label, labelOptions, highlightOptions, markerOptions) {\r\n  if(!($.isEmptyObject(lat) || $.isEmptyObject(lng)) ||\r\n      ($.isNumeric(lat) && $.isNumeric(lng))) {\r\n    const map = this;\r\n\r\n    // Function to normalize access to values, either from arrays or scalars\r\n    const getValue = (prop, index) => Array.isArray(prop) ? (prop[index] || prop[prop.length - 1]) : prop;\r\n\r\n    const locations = [];\r\n    for (let i = 0; i < lat.length; i++) {\r\n        locations.push({\r\n            lat: getValue(lat, i),\r\n            lng: getValue(lng, i),\r\n            radius: getValue(radius, i),\r\n            popup: getValue(popup, i),\r\n            label: getValue(label, i),\r\n            weight: getValue(options.weight, i),\r\n            color: getValue(options.color, i),\r\n            opacity: getValue(options.opacity, i),\r\n            steps: getValue(options.steps, i),\r\n        });\r\n    }\r\n    console.log(\"locations\"); console.log(locations)\r\n    console.log(\"options\");console.log(options);\r\n\r\n    // Add GeodesicCircle and Center Marker\r\n    locations.forEach(location => {\r\n      const latlong = new L.LatLng(location.lat, location.lng)\r\n      // Create a marker for each location\r\n      const marker = L.marker(latlong, markerOptions)\r\n        .bindTooltip(location.label, labelOptions)\r\n        .bindPopup(location.popup, popupOptions)\r\n        .addTo(map);\r\n\r\n      // Create a geodesic circle for each marker\r\n      const geodesicCircle = new L.GeodesicCircle(latlong, {\r\n          weight: location.weight,\r\n          opacity: location.opacity,\r\n          color: location.color,\r\n          steps: location.steps,\r\n          fill: options.fill === true,\r\n          wrap: options.wrap === true,\r\n          dashArray: options.dashArray,\r\n          smoothFactor: options.smoothFactor,\r\n          noClip: options.noClip,\r\n      }).addTo(map);\r\n\r\n      // Drag event listener for Center marker\r\n      marker.on('drag', (e) => {\r\n          // Update the geodesic circle's position and information\r\n          geodesicCircle.setLatLng(e.latlng);\r\n\r\n          // Assuming 'info' and 'updateInfo' function are defined elsewhere to update the control based on new stats\r\n          if (options.showStats) {\r\n            updateInfo(geodesicCircle.statistics); // You need to define or adjust the 'updateInfo' function\r\n          }\r\n\r\n          // Listen for Events in Shinymode\r\n          if (HTMLWidgets.shinyMode) {\r\n            Shiny.onInputChange(map.id + \"_geodesic_stats\", geodesicCircle.statistics);\r\n          }\r\n      });\r\n\r\n      // Highlight -\r\n      // TODO - Not working as Circle is a Polyline and therefore `mouseout` is not trigered\r\n      /*\r\n      let highlightStyle = highlightOptions;\r\n      if(!$.isEmptyObject(highlightStyle)) {\r\n        console.log(\"highlightOptions\");console.log(highlightOptions);\r\n        let defaultStyle = {};\r\n        $.each(highlightStyle, function (k, v) {\r\n          console.log(\"location\");console.log(location);\r\n          console.log(\"k\");console.log(k);\r\n          console.log(\"v\");console.log(v);\r\n          if (k != \"bringToFront\" && k != \"sendToBack\"){\r\n            if (location[k]) {\r\n              defaultStyle[k] = location[k];\r\n            }\r\n          }\r\n        });\r\n\r\n        geodesicCircle.on(\"mouseover\",\r\n          function(e) {\r\n            this.setStyle(highlightStyle);\r\n            if(highlightStyle.bringToFront) {\r\n              this.bringToFront();\r\n            }\r\n          });\r\n        geodesicCircle.on(\"mouseout\",\r\n          function(e) {\r\n            this.setStyle(defaultStyle);\r\n            if(highlightStyle.sendToBack) {\r\n              this.bringToBack();\r\n            }\r\n          });\r\n      }\r\n      */\r\n\r\n\r\n    });\r\n\r\n\r\n    if (options.showStats) {\r\n      // Info control\r\n      var info = L.control();\r\n      info.onAdd = function(map) {\r\n          this._div = L.DomUtil.create('div', 'info');\r\n          return this._div;\r\n      };\r\n      info.addTo(map);\r\n\r\n\r\n      // Define a function to update the info control based on passed statistics\r\n      function updateInfo(stats, statsFunction) {\r\n        console.log(\"update info\"); console.log(stats);\r\n        var infoHTML = \"\";\r\n        if (typeof options.statsFunction === \"function\") {\r\n          // If additionalInput is a function, use it to generate content exclusively\r\n          infoHTML = options.statsFunction(stats);\r\n        } else {\r\n          // Default content generation logic\r\n          const totalDistance = stats.totalDistance ? (stats.totalDistance > 10000 ? (stats.totalDistance / 1000).toFixed(0) + ' km' : stats.totalDistance.toFixed(0) + ' m') : 'invalid';\r\n          infoHTML = '<h4>Statistics</h4>' +\r\n            '<b>Total Distance</b><br/>' + totalDistance +\r\n            '<br/><br/><b>Points</b><br/>' + stats.points +\r\n            '<br/><br/><b>Vertices</b><br/>' + stats.vertices;\r\n        }\r\n        // Update the innerHTML of the info div with the constructed info HTML or leave it empty\r\n        info._div.innerHTML = infoHTML;\r\n      }\r\n    }\r\n\r\n\r\n  }\r\n};\r\n"],"names":[],"sourceRoot":""}